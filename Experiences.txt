-- Contar sonre el problema que tuve de permisos con inline actions a otros contratos --
    - los inline actions de un contrato al mismo contrato funcan bien de una
    - ara los inline actions entre dos contratos el contrato emisor debe tener el permiso "eosio.code"
-- los inline actions no se ejecutan "inline" sino que se ejecutan al terminar la ejecusión de la acción actual
    - es un error mandar una inline action (desde A a B) y querer ver los resultados de dicha invocación (a B) dentro del mismo código (de A) porque B no ejecutó aun.
-- Dos acciones consecutivas se ejecutan e el orden que fueron llamadas (era esperable)
-- alargar el ktimeout de la wallet de keosd para trabajar más cómodo
-- es cómodo crear algunos scripts para automaticar ciertas ineracciones con la blockchain que de otro sería muy tedioso como:
    - visualizar tablas
    - resetear el estado de la blockchain
-- al deployar me sorprendió que necesité x10 veces más de RAM de lo que pesa el archivo original!!!
   vapaeetokens.wasm 37Kb, pero fueron 374Kb de RAM
   boardgamebox.wasm 201Kb, pero 2Mb de RAM
   - account boardgamebox has insufficient ram; needs 2022497 bytes has 1964380 bytes
-- Al mandar actiones en linea sucede que no se generan errores de typo en tiempo de compilación.
   basicamentye podés mandar cualquier cantidad de parámetros de cualquier typo pero explota en tiempo de ejecusión.
   hay que verificar cantidad y typo de cada parámetro.
    ej: 
    // el siguiente mensaje en linea da error por el array de caracteres "airdrop"
    action(
        permission_level{owner,"active"_n},
        get_self(),
        "issue"_n,
        std::make_tuple(owner, quantity, "airdrop")
    ).send();
    // lo correcto sería
    action(
        permission_level{owner,"active"_n},
        get_self(),
        "issue"_n,
        std::make_tuple(owner, quantity, string("airdrop"))
    ).send();
-- El lower_bounds y el upper_bounds no son tan fáciles de usar.
for (auto p = table.begin(); p != table.end(); p++) {
    print(p->id);
}
for (auto p = table.begin(); p != table.end(); p = table.begin()) {  // <------ p++ no se puede hacer si borrás el puntero
    table.erase(p)
}
